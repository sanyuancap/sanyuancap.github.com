# 正则表达式学习

## 正则的作用

操作字符串

## 正则对象属性

```js
/hello, world!/i
new RegExp('hello, world!', 'i')// 运行时编译为正则

/hello/.test('hellom world!') // 模式是否匹配
/hello/.exec('hello, world!') // 返回结果

// g 全局修饰符
var str = 'hello, world!'
var re1 = /hello/
var re2 = /hello/g

re1.test(str) // true lastIndex 0
re1.test(str) // true lastIndex 0
re2.test(str) // true lastIndex 5
re2.test(str) // false lastIndex null

// lastIndex 模式开始匹配的起始位置
// global (g) 模式是否设置了全局修饰符
// ignoreCase(i) 模式是否设置了忽略大小写修饰符

/l(lo)/.test('hello, world!')
/l(..)/.test('hello, world!')

// input $_ 模糊搜索所针对的字符串
// lastMatch $&
// lastParen $+
// leftContext $`
// rightContext $'
// $1-$9

RegExp['$_'] == RegExp.input

```

## 正则语法

**要么匹配字符，要么匹配位置**

**字符池只匹配一个字符**

```js
'￥9999'.replace(/￥/, '$$') // $9999

/[123]/.test('14'); // true // 只匹配一个字符

/^[123]$/.test('12');  // false 行首和行尾

/^\d\d\d$/.test('002'); // \d 代表 0-9

\d [0-9]
\D [^0-9] // 对小写取反
\w（数字+大小写+下划线）
\s 空白符
\S
.   [^\n\r\u2028\u2029] 代表通配符：换行符、回车符、航分隔符和段分隔符除外

/[A-Za-z]/.test('t'); == /[a-z]/i.test('t');

// 匹配任意字符
/[\d\D]/
/[^]/
/./s

```

1. ASCII码表
2. Unicode码表（包含了ASCII码表，中文，罗马，希腊文等）

 - 量词

```js
/^\d{3}$/.test('002')

/~jsx{0,1}$/.test('js') == /~jsx?$/.test('js')// 有或者没有

/^\d{1,}px$/.test('5px') == /^\d+px$/

/^\d{0,}[0]5px$/.test('.5px') // [.]代表匹配小数点，有转义字符的意思，如果只有.符号，代表匹配所有，不代表小数点

/^\d*(\.\d+)?px$/.test('.5px')// （）括号代表分组，后面跟着问号，代表整体可以出现，也可以不出现

?问号等价于{0,1}//可出现，可出现一次

*星号等价于出现出现0次或者多次{0,}
+加号等价于出现至少一次{1,}

```
 - 贪婪匹配 vs 非贪婪匹配
**非贪婪匹配（最小匹配）消耗性能**

```js
/id=".*"/.exec('<div id="container" meta="cjytest" ></div>')// id="container" meta="cjytest"

/id=".*?"/.exec('<div id="container" meta="cjytest" ></div>')// id="container"
```

 - 分支
 
```js
// 优先级 
/^(\.jpe?g|\.png|\.gif)$/,test('.png12') // false
/^\.jpe?g|\.png|\.gif$/,test('.png12') // true
```

 - 分组

```js
// "2019-03-27"
/\d{4}-\d{2}-\d{2}/.exec('2019-03-27')

// "2019-03-27", "2019', "03", "27"
/(\d{4})-(\d{2})-(\d{2})/.exec('2019-03-27')

```

 - 零宽断言

 - 位置

 - 字符串

match() replace() search() split()

search() 做一次搜索即可

match() 匹配做一次即可

replace() 字符串会有隐式转换为正则，例如'b'

**使用全局g符号时会忽略分组**


