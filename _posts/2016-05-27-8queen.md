---
layout: post
title: "8queen"
description: ""
category: 
tags: []
---
{% include JB/setup %}

对称加密 ：同一秘钥
采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。

切入点：秘钥
因此加密的安全性不仅取决于加密算法本身，密钥管理的安全性更是重要。因为加密和解密都使用同一个密钥，如何把密钥安全地传递到解密者手上就成了必须要解决的问题。

甲乙约定，一起买一个保险箱，保存金银财宝，共用一个钥匙。只要甲乙小心保管好钥匙，那么就算有人得到保险盒，也无法打开。


常用算法：
CryptoJS (crypto.js) 为 JavaScript 提供了各种各样的加密算法。
目前已支持的常见算法包括：
DES、TripleDes、AES、RC4、Rabbit等。

AES加密
　AES（The Advanced Encryption Standard）是美国国家标准与技术研究所用于加密电子数据的规范。它被预期能成为人们公认的加密包括金融、电信和政府数字信息的方法。近些年DES使用越来越少，原因就在于其使用56位密钥，比较容易被破解，近些年来逐渐被AES替代，AES已经变成目前对称加密中最流行算法之一；AES可以使用128、192、和256位密钥，并且用128位分组加密和解密数据。

加密解密示例：
<script type="text/javascript" src="http://www.osctools.net/js/CryptoJS/components/core-min.js"></script>
<script type="text/javascript" src="http://www.osctools.net/js/CryptoJS/rollups/aes.js"></script>
<script type="text/javascript">
  var pwd="我的密码";
  
  var mi=CryptoJS.AES.encrypt("你好，欢迎来到开源中国在线工具，这是一个AES加密测试",pwd);
  alert("你好，欢迎来到开源中国在线工具，这是一个AES加密测试----密文:"+mi);
  
  var result=CryptoJS.AES.decrypt(mi,pwd).toString(CryptoJS.enc.Utf8);
  
  alert("解密结果："+result);
  
</script>


CryptoJS还支持base64加密
base64是当前网络上最为常见的传输8Bit字节代码的编码方式其中之一。base64主要不是加密，它主要的用途是把某些二进制数转成普通字符用于网络传输。
由于这些二进制字符在传输协议中属于控制字符，不能直接传送，所以需要转换一下。
虽然图片可能直接传输，但是我们也可以将它变成字符串直接放在源码里，而不需要浏览器在读取到源码后再从服务器上下载。
图片的下载始终都要向服务器发出请求，要是图片的下载不用向服务器发出请求，而可以随着 HTML 的下载同时下载到本地那就太好了，而base64正好能解决这个问题。
在这里要明确使用base64的一个前提，那就是被base64编码的图片足够尺寸小。
解决跨域问题。
原理：
canvas.toDataURL() 首先把图像转成 PNG 数据，然后再把得到的二进制的 PNG 数据转成纯 ASCII 的 base64 编码的字符串。

8皇后是什么
八皇后问题是十九世纪著名数学家高斯于1850年提出的。
问题是：在8*8的棋盘上摆放8个皇后，使其不能互相攻击，即任意的两个皇后不能处在同意行，同一列，或同意斜线上。

对于某个满足要求的8皇后的摆放方法，定义一个皇后串a与之对应，即a=b1b2...b8，其中bi为相应摆法中第i行皇后所处的列数。已经知道8皇后问题一共有92组解（即92个不同的皇后串）。
例如：15863724，代表皇后分别在第一行的第一个位置，第2行的第5个位置...等。

这是一个古老的具有代表性的问题，用计算机求解时的算法也很多，最容易想到的是回溯法，采用一维数组来进行处理。数组的下标i表示棋盘上的第i列，a[i]的值表示皇后在第i列所放的位置。如：a[1]=5，表示在棋盘的第一例的第五行放一个皇后。
程序中首先假定a[1]=1，表示第一个皇后放在棋盘的第一列的第一行的位置上，然后试探第二列中皇后可能的位置，找到合适的位置后，再处理后续的各列，这样通过各列的反复试探，可以最终找出皇后的全部摆放方法。

在这些算法当中，比较个性和效率的算法是位算法。
简单的看了一下算法原理，它有别于传统的数组判断模式，而是采用了位运算。

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

long sum = 0, upperlim = 1;

void test(long row, long ld, long rd)
{

   if (row != upperlim)
   {
  long pos = upperlim & ~(row | ld | rd);
  while (pos)
  {
 long p = pos & -pos;

 pos -= p;
 test(row + p, (ld + p) << 1, (rd + p) >> 1);
  }
   } else
  sum++;
}

int main(int argc, char *argv[])
{
   time_t tm;
   int n = 16;

   if (argc != 1)
  n = atoi(argv[1]);
   tm = time(0);
   if ((n < 1) || (n > 32))
   {
  printf(" 只能计算1-32之间\n");
  exit(-1);
   }
   printf("%d 皇后\n", n);
   upperlim = (upperlim << n) - 1;

   test(0, 0, 0);
   printf("共有%ld种排列, 计算时间%d秒 \n", sum, (int) (time(0) - tm));
}

js版本：

        //八皇后问题
        var size = 8;
        var np_reverse = function( d, a, b ) {
            var sub = d.slice( a, b+1 ).reverse();
            for ( var i = a; i <= b; i++ ) {
                d[i] = sub[i-a];
            }
        }

        var next_permutation = function( d ) {
            var i = d.length - 1;
            while ( i > 0 ) {
                var k = i;
                i--;
                if ( d[i] < d[k] ) {
                    var j = d.length-1;
                    while ( d[i] >= d[j] ) {
                        j--;
                    }
                    d[i] = d.splice( j, 1, d[i] )[0];
                    np_reverse( d, k, d.length-1 );
                    return true;
                }
            }
            return false;
        }
        var _self = this;
        function main(){
            var resultNum = 0;
            var board = new Array(size);
            var left = new Array(2*size - 1);
            var right = new Array(2*size - 1);

            var i;
            for ( i = 0; i < board.length; i++) {
                board[i] = i;
            }
            //核心循环
            do{
                for (var i = 0; i < left.length; i++) {
                    left[i] = false;
                }
                for (var i = 0; i < right.length; i++) {
                    right[i] = false;
                }
                for (i = 0; i < size; i++) {
                    var south_west = i + board[i];
                    var south_east = size - 1 - i + board[i];
                    if (left[south_west] || right[south_east]) {
                        break;
                    } else {
                        left[south_west] = right[south_east] = true;
                    }
                }

                var retval = '';
                if (i === size) {
                    for (var i = 0; i < board.length; i++) {
                        retval += (board[i] + 1) + " ";

                    }
                    console.log(retval);

                    if(resultNum < 10){
                        resultNum ++;
                        var helloLabel = new cc.LabelTTF(resultNum + "月： " + retval, "Arial", 38);
                        helloLabel.x = 300;
                        helloLabel.y = 700 - resultNum * 50;

                        _self.addChild(helloLabel, 999);
                    }

                }

            }while(next_permutation(board));

        }

        main();
        




